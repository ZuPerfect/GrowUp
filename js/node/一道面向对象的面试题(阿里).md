 # 变量提升（需彻底理解）
 ### 在当前作用域下（在当前的执行上下文下），在所有JS代码执行之前，把所有带var和所有带function关键字的提前的声明（创建一个变量）或者定义（给一个变量赋值）。带var的值***提前声明***，带function的***提前声明+定义***。贴段代码帮助我们理解这个概念：

 ``` js
var getName = function () {
    console.log(4);
}

function getName() {
    console.log(5);
}

getName(); //输出4
 ```
 为什么这里的getName()输出的是4呢❓下面我们分两个阶段分析😊：
 
 **1、代码执行之前：** 处理带有var和function关键字的语句，流程如下：

 1. var的提前声明，则定义了一个叫getName的变量，***<u>但是不赋值，因为这是代码执行之前！</u>***
 2. function的提前声明+定义，则定义了一个叫getName的变量，但是发现getName变量已经被定义，那么只是将一个函数赋给了它。此时getName=fuc=>5

 **2、代码执行时：** 给getName复制，此时getName=fuc=>4

 # 理解完上面这个概念之后，我们再看下面这道题
 ``` js
function Foo() {
    getName = function () {
        console.log(1);
    }
    return this;
}

Foo.getName = function () {
    console.log(2);
}

Foo.prototype.getName = function () {
    console.log(3);
}

var getName = function () {
    console.log(4);
}

function getName() {
    console.log(5);
}

Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new Foo.getName(); // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
 ```
 ## 解析:
 
 明天再写吧.....头疼😫

 和老友叙旧2个多小时，为了兄弟们的终身大事，我操碎了心😂！这部分明天周六补上！

 周六早上起床真的太难了！！！

 ## 咱们继续（拖延症得治！！）(ง •_•)ง：
 根据上面的变量提升的概念，我们知道在代码运行之前是***变量提升***。

**1、所以第一步（变量提升）：** 寻找function和var关键字的代码
``` js
// 第一个function Foo() { ... }，function关键字，声明+定义
Foo = AAAFFFOOO  // 这里的AAAFFFOOO假设是Function对象在堆内存中的引用地址

// 第一个var getName = ... ,var关键字只声明
getName = undefined // 再次再强调一遍，var只声明，不定义，所以此时getName的值是undefined

// 第二个function getName() { ... }，function关键字，声明+定义。但是发现getName变量已经在上一步被声明，所以只需要定义就行，即赋值即可
getName = func=>5 // 这里是伪代码，func=>5表示输出5的那个方法在堆内存中的引用地址，后续将全部按照这种写法
```
至此，变量提升完毕！我们可以看到的是，目前***全局的getName指向的是func=>5***

**2、接下来第二步（代码执行）：** 我们一句一句来看

第一句
 ``` js
function Foo() {
    getName = function () {
        console.log(1);
    }
    return this;
}
 ```
 变量提升阶段已完成，当前内存图如下：

 第二句

 


